module codegen/codegen-exp

imports
  
  milestone1/MiniJava
  milestone2/MiniJava.core
  lib/jasmin/JasminXT
  trans/codegen/-
  
rules
  
  // IntValue    : INT -> Exp
  exp-to-jbc: IntValue(i) -> [LDC(i)]
  
  // True        : Exp
  // False       : Exp
  exp-to-jbc: True() -> [ICONST_1()]
  exp-to-jbc: False() -> [ICONST_0()]
  
  //UnExp     : UnOp * Exp -> Exp
  exp-to-jbc: UnExp(op, e) -> <concat> [<exp-to-jbc>e,<op-to-jbc>op]
  
  //BinExp    : BinOp * Exp * Exp -> Exp
  exp-to-jbc: BinExp(op, e1, e2) -> <concat>[<exp-to-jbc>e1,<exp-to-jbc>e2,<op-to-jbc>op]
  // And recieves special treatment because of lazy evaluation
  exp-to-jbc: BinExp(And(), e1, e2) -> out*
  	where
  		<debug> "entering And() exp-to-jbc"
  	;	falselbl := <newname> "false_"
  	;	endlbl	 := <newname> "end_"
  	;	out_e1*	 := <exp-to-jbc>e1
  	;	out_e2*	 := <exp-to-jbc>e2	
  	;	out*	 := [
  			out_e1*,
  			IFEQ(LabelRef(falselbl)),
  				out_e2*,
  				IFEQ(LabelRef(falselbl)),
  					ICONST_1(),
  					GOTO(LabelRef(endlbl)),
  			JBCLabel(falselbl),
  			ICONST_0(),
  			JBCLabel(endlbl)
  		]
  
  /** Operators **/
  //  Not      : UnOp
  //  !value == value ^ 1
  op-to-jbc: Not() -> [ICONST_1(), IXOR()]
  // Length    : UnOp
  op-to-jbc: Length() -> [ARRAYLENGTH()]
  // NewArray  : UnOp
  op-to-jbc: NewArray() -> [NEWARRAY(Int())]
  
  // Plus      : BinOp
  op-to-jbc: Plus() -> [IADD()]
  // Minus     : BinOp
  op-to-jbc: Minus() -> [ISUB()]
  // Times     : BinOp
  op-to-jbc: Times() -> [IMUL()]
  // Subscript : BinOp
  op-to-jbc: Subscript() -> [IALOAD()]
  // Lt        : BinOp
  // a < b is equivalent to (a - b) >>> 31
  // This never overflows because MiniJava is restricted to 31-bit unsigned integers
  op-to-jbc: Lt() -> [ISUB(), LDC(31), IUSHR()]
  
  