module codegen/codegen-method

imports
  
  milestone1/MiniJava
  milestone2/MiniJava.core
  lib/jasmin/JasminXT
  trans/codegen/-
  
  lib/runtime/nabl/-
  lib/runtime/types/-
  
rules

	// Method      : Type * ID * List(ParamDecl) * List(VarDecl) * List(Statement) * Exp -> MethodDecl	
	method-to-jbc: Method(rettype, mname, params*, vars*, stmt*, retexp) ->
		JBCMethod(
		   [PUBLIC()]				// Every MiniJava method is public
		  ,<strip-annos> mname		// Method name
		  ,<get-descriptor> mname	// Method signature/descriptor
		  ,methodstatements
		)
	where
		stmtjbc*		:= <map(stmt-to-jbc); concat> stmt*
	;	stmtstacklimit	:= <map(stack-limit) ; foldr(!0, max)> stmt* // list-max doesn't work on the empty list
	;	stacklimit		:= <max> (<stack-limit> retexp, stmtstacklimit)
	//; stacklimit		:= 100
	//;	<debug> stacklimit
	;	retexpjbc*		:= <exp-to-jbc> retexp
	;	methodstatements:= [JBCLimitStack(<int-to-string>stacklimit),stmtjbc*,retexpjbc*,<j-retexp> rettype]
	
	// Create method descriptor
	nabl-prop-site(|lang, ctx, uris, states, implicits):
	  Method(ty, mname, param*, var*, stmt*, exp) -> <fail>
	  where
	  	descr := JBCMethodDesc(<map(paramtype;type-to-jbc)> param*, <type-to-jbc> ty) // Method description: (params, return type)
	  ; <store-descriptor(|ctx, descr)> mname 	
	    
rules // helper rules	
	j-retexp: Bool() -> IRETURN()
	j-retexp: Int() -> IRETURN()
	j-retexp: IntArray() -> ARETURN()
	j-retexp: ClassType(_) -> ARETURN()
	
	paramtype: Param(t, _) -> t