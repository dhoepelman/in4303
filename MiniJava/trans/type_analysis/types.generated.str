module trans/type_analysis/types.generated

imports
  lib/runtime/nabl/-
  lib/runtime/task/-
  lib/runtime/types/-
  lib/runtime/properties/-
  
  
rules
  
  create-type-task(|ctx) :
    IntValue(v) -> <type-is(|ctx, [])> Int()
    where id
  
  create-type-task(|ctx) :
    True() -> <type-is(|ctx, [])> Bool()
    where id
  
  create-type-task(|ctx) :
    False() -> <type-is(|ctx, [])> Bool()
    where id
  
  create-type-task(|ctx) :
    NewObject(c) -> <type-is(|ctx, [])> ClassType(c)
    where id
  
  create-type-task(|ctx) :
    UnExp(operator, exp) -> <type-is(|ctx, [ety1, t54, ty1, ty, eq302])> ty
    where ety1 := <type-task(|ctx)> exp;
          t54 := <type-task(|ctx)> operator;
          ty1 := <new-task(|ctx)> Rewrite("proj166", t54);
          ty := <new-task(|ctx)> Rewrite("proj167", t54);
          eq302 := <type-match(|ctx, ty1)> ety1;
          <task-create-error-on-failure(|ctx, eq302, "Incompatible type")> exp
  
  create-type-task(|ctx) :
    Negation() -> <type-is(|ctx, [])> (Bool(), Bool())
    where id
  
  create-type-task(|ctx) :
    ArrayLength() -> <type-is(|ctx, [])> (IntArray(), Int())
    where id
  
  create-type-task(|ctx) :
    AllocateArray() -> <type-is(|ctx, [])> (Int(), IntArray())
    where id
  
  create-type-task(|ctx) :
    BinExp(operator, subexp1, subexp2) -> <type-is(|ctx, [ety1, ety2, t55, ty1, ty2, ty, eq303, eq304])> ty
    where ety1 := <type-task(|ctx)> subexp1;
          ety2 := <type-task(|ctx)> subexp2;
          t55 := <type-task(|ctx)> operator;
          ty1 := <new-task(|ctx)> Rewrite("proj163", t55);
          ty2 := <new-task(|ctx)> Rewrite("proj164", t55);
          ty := <new-task(|ctx)> Rewrite("proj165", t55);
          eq303 := <type-match(|ctx, ty1)> ety1;
          <task-create-error-on-failure(|ctx, eq303, "Incompatible type")> subexp1;
          eq304 := <type-match(|ctx, ty2)> ety2;
          <task-create-error-on-failure(|ctx, eq304, "Incompatible type")> subexp2
  
  create-type-task(|ctx) :
    LogicalAnd() -> <type-is(|ctx, [])> (Bool(), Bool(), Bool())
    where id
  
  create-type-task(|ctx) :
    LessThan() -> <type-is(|ctx, [])> (Int(), Int(), Bool())
    where id
  
  create-type-task(|ctx) :
    Times() -> <type-is(|ctx, [])> (Int(), Int(), Int())
    where id
  
  create-type-task(|ctx) :
    Minus() -> <type-is(|ctx, [])> (Int(), Int(), Int())
    where id
  
  create-type-task(|ctx) :
    Plus() -> <type-is(|ctx, [])> (Int(), Int(), Int())
    where id
  
  create-type-task(|ctx) :
    ArrayAccess() -> <type-is(|ctx, [])> (IntArray(), Int(), Int())
    where id
  
  create-type-task(|ctx) :
    VarRef(r) -> <type-is(|ctx, [ty])> ty
    where ty := <type-lookup(|ctx)> r
  
  create-type-task(|ctx) :
    Param(t, name) -> <type-is(|ctx, [])> t
    where id
  
  nabl-constraint(|ctx) :
    ArrayAssign(var, idx, exp) -> <fail>
    where tvar := <type-lookup(|ctx)> var;
          tidx := <type-task(|ctx)> idx;
          texp := <type-task(|ctx)> exp;
          eq305 := <type-match(|ctx, IntArray())> tvar;
          <task-create-error-on-failure(|ctx, eq305, "Not an array")> var;
          eq306 := <type-match(|ctx, Int())> tidx;
          <task-create-error-on-failure(|ctx, eq306, "Array index needs to be an integer")> idx;
          eq307 := <type-match(|ctx, Int())> texp;
          <task-create-error-on-failure(|ctx, eq307, "Incompatible array and expression type")> exp
  
  nabl-constraint(|ctx) :
    Assign(var, exp) -> <fail>
    where tvar := <type-lookup(|ctx)> var;
          texp := <type-task(|ctx)> exp;
          subtype60 := <create-subtype-task(|ctx)>("<:", texp, tvar);
          <task-create-error-on-failure(|ctx, subtype60, "Incompatible variable and expression type")> exp
  
  nabl-constraint(|ctx) :
    Print(exp) -> <fail>
    where texp := <type-task(|ctx)> exp;
          eq308 := <type-match(|ctx, Int())> texp;
          <task-create-error-on-failure(|ctx, eq308, "Incompatible expression type: can only print integers")> exp
  
  nabl-constraint(|ctx) :
    While(exp, statements) -> <fail>
    where texp := <type-task(|ctx)> exp;
          eq309 := <type-match(|ctx, Bool())> texp;
          <task-create-error-on-failure(|ctx, eq309, "Incompatible expression type: condition must be boolean")> exp
  
  nabl-constraint(|ctx) :
    If(exp, ifstmt, elsestmt) -> <fail>
    where texp := <type-task(|ctx)> exp;
          eq310 := <type-match(|ctx, Bool())> texp;
          <task-create-error-on-failure(|ctx, eq310, "Incompatible expression type: condition must be boolean")> exp
  
  nabl-constraint(|ctx) :
    Method(treturn, mname, params, vars, statements, retexp) -> <fail>
    where tretexp := <type-task(|ctx)> retexp;
          subtype61 := <create-subtype-task(|ctx)>("<:", tretexp, treturn);
          <task-create-error-on-failure(|ctx, subtype61, "Incompatible return and expression type")> retexp
  
  create-type-task(|ctx) :
    None() -> <type-is(|ctx, [])> Top()
    where id
  
  create-type-task(|ctx) :
    Parent(c) -> <type-is(|ctx, [])> ClassType(c)
    where id
  
  create-subtype-task(|ctx) :
    ("<:", type-used, type-expected) -> or27
    where eq311 := <type-match(|ctx, type-expected)> type-used;
          cused := <new-task(|ctx)> Rewrite("proj162", type-used);
          parenttype := <type-lookup(|ctx)> cused;
          eq312 := <type-match(|ctx, parenttype)> type-expected;
          or27 := <new-task(|ctx)> Choice([eq311,eq312])
  
  
rules // projections
  
  task-rewrite :
    ("proj167", (ty1, ty)) -> ty
  
  task-rewrite :
    ("proj166", (ty1, ty)) -> ty1
  
  task-rewrite :
    ("proj165", (ty1, ty2, ty)) -> ty
  
  task-rewrite :
    ("proj164", (ty1, ty2, ty)) -> ty2
  
  task-rewrite :
    ("proj163", (ty1, ty2, ty)) -> ty1
  
  task-rewrite :
    ("proj162", ClassType(cused)) -> cused
  
