module trans/type_analysis/typesystem

imports
  lib/runtime/nabl/-
  lib/runtime/task/-
  lib/runtime/types/-
  lib/runtime/properties/-
  
  assignment1/MiniJava
  analysis/desugar
  
  type_analysis/types.generated
  
rules
  
  // Literals and object creations are defined in types.ts
  
  // Unary operator
  create-type-task(|ctx):
  	UnExp(e1, e2) -> <type-is(|ctx, [task2])> ty
  	where
  			(ty1,ty) := <type-of-op> e1
  		;	task1 := <type-task(|ctx)> e1
  		;	task2 := <type-match(|ctx, ty1)> task1
  // Constraints of Unary operators
  type-of-op: Negation() -> (Bool(), Bool())
  type-of-op: ArrayLength() -> (IntArray(), Int())
  type-of-op: AllocateArray() -> (Int(), IntArray())
  
  // Binary operator
  create-type-task(|ctx):
  	BinExp(e1, e2, e3) -> <type-is(|ctx, [task2, task4])> ty
  	where
  			(ty1,ty2,ty) := <type-of-op> e1
  		;	task1 := <type-task(|ctx)> e1
  		;	task2 := <type-match(|ctx, ty1)> task1
  		;	task3 := <type-task(|ctx)> e2
  		;	task4 := <type-match(|ctx, ty2)> task3
  // Constraints of Binary operators
  type-of-op: LogicalAnd() -> (Bool(), Bool(), Bool())
  type-of-op: LessThan() -> (Int(), Int(), Bool())
  type-of-op: Times() -> (Int(), Int(), Int())
  type-of-op: Minus() -> (Int(), Int(), Int())
  type-of-op: Plus() -> (Int(), Int(), Int())	 	
  type-of-op: ArrayAccess() -> (IntArray(), Int(), Int())
  
  // References
  // References are implemented in types.ts, manual implementation below
  /*
  create-type-task(|ctx) :
    VarRef(r) -> <type-is(|ctx, [task])> task
    where task := <type-lookup(|ctx)> r
    */
    
  // This
  // TODO: this binden
  //create-type-task(|ctx): 
  //ClassType(e) -> <type-is(|ctx, [task])> task
  //where
  //  This() := e
  //; task   := <type-lookup(|ctx)> e
  //create-type-task(|ctx):
  //	This() -> <type-is(|ctx) ty
  //		ty := <type-lookup(|ctx)>
  //create-type-task(|ctx) :
  //	This() -> <type-is(|ctx, [task])> task
  //		where task := <type-lookup(|ctx)